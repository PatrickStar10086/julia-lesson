using JuMP,Random,Gurobi

##定义参数
N = 20    #工件数量
B = 5    #每条生产线模台数量
L = 3     #生产线数量
W = 5     #每条生产线上的工作站数量
#k = [5,3,6,4,3,4,5,6,4,5,6,3,4,6,5,6,4,5,6,5,8,5,6,4,4,6,5,8,7,4,7,6,5,8,5,6,6,8,4,5,6,4,6,9,4,8,7,5,6,4,8,9,7,5,4,6,8,4,7,9,4,6,8,5,7,9,6,4,8,5,9,6,4,7,8,9,5,8,6,7]      #工件宽度
#g = [2,1,2,2,2,2,3,4,4,3,3,1,3,4,5,1,1,3,1,2,6,4,5,4,2,4,2,7,4,1,5,4,5,6,2,4,2,4,4,5,6,2,5,8,4,5,6,5,4,3,5,6,4,2,4,5,6,3,5,8,2,6,8,4,8,2,4,3,5,4,8,5,4,5,6,4,2,4,5,4]      #工件高度
# k = [5,3,6,4,3,4,5,6,4,5,6,3,4,6,5,6,4,5,6,5,8,5,6,4,4,6,5,8,7,4,7,6,5,8,5,6,6,8,4,5]      #工件宽度
# g = [3,2,4,2,2,2,3,4,4,3,4,1,3,4,5,1,1,3,1,2,6,4,5,4,2,4,3,7,4,2,5,4,5,6,2,4,2,4,4,5]      #工件高度
k = [5,3,6,4,3,4,5,6,4,5,6,3,4,6,5,6,4,5,6,5]       #工件宽度
g = [3,2,4,2,2,2,3,4,4,3,4,1,3,4,5,1,1,3,1,2]       #工件高度
WB = 10     #锚台宽度
HB = 10      #锚台高度
A = 1000      #一个足够大的数     
alpha = 0     #权重

# 设置随机数生成器的种子，以确保结果可重复
# Random.seed!(123)

# piwl = Array{Int}(undef, N, W, L)
# for i in 1:N
#     for w in 1:W
#         for l in 1:L
#             if 0 < k[i] *g[i] <= 10
#             piwl[i, w, l] = rand(1:10)  # 这里的 1:10 表示加工时间的范围
#             elseif 10 < k[i] *g[i] <= 20
#             piwl[i, w, l] = rand(10:20)
#             elseif 20 < k[i] *g[i] <= 30
#             piwl[i, w, l] = rand(20:30)
#             elseif 30 < k[i] *g[i] <= 40
#             piwl[i, w, l] = rand(30:40)
#             elseif 40 < k[i] *g[i] <= 50
#             piwl[i, w, l] = rand(40:50)
#             elseif 50 < k[i] *g[i] <= 60
#             piwl[i, w, l] = rand(50:60)
#             end
#         end
#     end
# end

piwl =  
[15 12 10 13 10; 2 7 10 4 4; 22 23 24 30 24; 10 2 3 7 7; 5 6 6 8 9; 7 7 2 1 3; 17 10 17 18 16; 30 27 23 27 20; 20 17 16 10 17; 12 15 11 10 20; 25 27 28 28 21; 2 7 10 2 4; 15 20 20 17 10; 25 21 28 27 20; 20 25 25 29 20; 1 9 7 5 2; 2 2 1 9 5; 18 20 19 12 11; 9 1 3 6 8; 10 8 8 9 10;;; 
 16 15 20 15 15; 8 3 9 2 5; 20 21 20 24 29; 9 6 9 10 9; 2 5 9 1 8; 5 8 2 7 7; 19 11 19 16 12; 23 25 28 20 20; 16 18 20 16 18; 20 11 16 16 18; 27 24 28 21 30; 1 3 2 7 1; 19 17 11 11 18; 25 22 27 20 25; 23 22 29 22 30; 1 9 9 4 2; 5 3 1 6 1; 20 18 12 15 12; 8 8 3 4 1; 9 8 3 2 10;;; 
 19 14 16 19 13; 6 3 3 1 8; 26 22 20 28 22; 8 9 4 8 5; 6 9 6 10 8; 1 10 1 7 4; 17 11 11 10 16; 30 23 27 25 20; 16 10 10 16 11; 14 12 14 11 20; 27 25 30 26 24; 4 3 3 6 9; 11 19 17 10 16; 24 28 24 22 26; 28 29 28 29 25; 2 9 7 4 3; 4 9 4 4 7; 17 17 19 19 11; 7 2 2 5 6; 10 9 6 3 6
]

# piwl = 
# [15 12 10 13 10; 2 7 10 4 4; 22 23 24 30 24; 10 2 3 7 7; 5 6 6 8 9; 7 7 2 1 3; 17 10 17 18 16; 30 27 23 27 20; 20 17 16 10 17; 12 15 11 10 20; 25 27 28 28 21; 2 7 10 2 4; 15 20 20 17 10; 25 21 28 27 20; 20 25 25 29 20; 1 9 7 5 2; 2 2 1 9 5; 18 20 19 12 11; 9 1 3 6 8; 10 8 8 9 10; 41 50 50 49 49; 15 20 17 18 15; 26 26 22 28 24; 19 20 19 15 11; 8 2 9 9 7; 30 27 26 28 28; 13 20 17 16 15; 55 59 57 60 55; 21 25 28 21 28; 4 6 8 6 1; 34 32 39 36 39; 26 25 22 27 24; 25 24 24 30 23; 40 49 47 44 48; 10 8 9 4 8; 26 20 22 21 30; 15 11 12 19 16; 39 39 31 33 31; 11 18 16 14 11; 22 29 20 30 22;;; 
# 16 15 20 15 15; 8 3 9 2 5; 20 21 20 24 29; 9 6 9 10 9; 2 5 9 1 8; 5 8 2 7 7; 19 11 19 16 12; 23 25 28 20 20; 16 18 20 16 18; 20 11 16 16 18; 27 24 28 21 30; 1 3 2 7 1; 19 17 11 11 18; 25 22 27 20 25; 23 22 29 22 30; 1 9 9 4 2; 5 3 1 6 1; 20 18 12 15 12; 8 8 3 4 1; 9 8 3 2 10; 50 47 43 46 43; 11 16 17 12 13; 24 22 28 27 20; 15 10 10 12 11; 6 2 2 9 6; 24 26 27 29 23; 18 12 16 10 20; 55 60 57 50 56; 26 26 26 22 29; 4 6 9 5 4; 36 37 35 33 38; 27 28 27 20 21; 29 28 27 25 23; 48 50 48 48 46; 9 6 4 9 2; 24 25 27 26 27; 11 14 18 12 18; 34 34 36 39 38; 11 11 16 11 10; 22 27 29 21 30;;; 
# 19 14 16 19 13; 6 3 3 1 8; 26 22 20 28 22; 8 9 4 8 5; 6 9 6 10 8; 1 10 1 7 4; 17 11 11 10 16; 30 23 27 25 20; 16 10 10 16 11; 14 12 14 11 20; 27 25 30 26 24; 4 3 3 6 9; 11 19 17 10 16; 24 28 24 22 26; 28 29 28 29 25; 2 9 7 4 3; 4 9 4 4 7; 17 17 19 19 11; 7 2 2 5 6; 10 9 6 3 6; 47 41 46 50 41; 18 15 11 19 18; 23 25 27 22 24; 18 13 16 10 20; 9 5 2 5 2; 28 25 21 22 26; 17 17 13 19 15; 51 52 58 55 57; 21 20 27 25 29; 7 3 8 8 4; 32 36 31 34 39; 23 26 25 30 30; 30 27 20 24 28; 46 43 47 45 48; 3 5 3 3 6; 29 28 28 22 25; 17 16 17 15 19; 34 34 34 33 40; 17 18 18 11 13; 26 30 29 27 30]

 # 创建模型
model = Model(Gurobi.Optimizer)

# 决策变量
@variable(model, gbl[1:B, 1:L], Bin)     # 如果生产线l上的模台b被激活则为1，否则为0
@variable(model, cibl[1:N, 1:B, 1:L], Bin)     # 如果工件i在生产线l上的模台b内加工则为1，否则为0
@variable(model, plij[1:N, 1:N], Bin)      #如果工件i放置在工件j左侧则为1，否则为0
@variable(model, puij[1:N, 1:N], Bin)      #如果工件i放置在工件j下侧则为1，否则为0
@variable(model, ei[1:N], Bin)     # 如果工件i的宽度与模台b的宽度平行则为1，否则为0
@variable(model, x[1:N] >= 0, Int)     # 模台b中的工件i的左下角横坐标
@variable(model, y[1:N] >= 0, Int)     # 模台b中的工件i的左下角纵坐标
@variable(model, cbwl[1:B, 1:W, 1:L] >= 0, Int)        #模台b在生产线l上的工作站w上的完工时间  
@variable(model, pbwl[1:B, 1:W, 1:L] >= 0, Int)        #模台b在生产线l上的工作站w上的加工时间
@variable(model, Cmax >= 0, Int)     #最大完工时间

# 目标函数
@objective(model, Min, alpha * sum(gbl[b, l] for l in 1:L for b in 1:B) + (1-alpha) * Cmax)    #最小化模台数量最大完工时间
# @objective(model, Min, Cmax)    #最小化模台数量最大完工时间

#约束
@constraint(model,[i in 1:N], sum(sum(cibl[i, b, l]) for b in 1:B for l in 1:L) == 1)    #一个工件只能在一条生产线的一个模台内加工
@constraint(model,[i in 1:N,b in 1:B,l in 1:L], cibl[i, b, l] <= gbl[b, l])    #工件只能放入被激活的模台
@constraint(model,[b in 1:B,l in 1:L], gbl[b, l] <= sum(cibl[i, b, l] for i in 1:N))    #生产线上至少存在一个工件需要加工才会激活模台
@constraint(model,[b in 1:B-1,l in 1:L], gbl[b+1, l] <= gbl[b, l])   #按顺序启用锚台
@constraint(model,[i in 1:N,b in 1:B,l in 1:L], x[i] + k[i] * ei[i] + (1 - ei[i]) * g[i] <= WB + A * (1 - cibl[i, b, l]))     # 工件宽度不能超过模台宽度
@constraint(model,[i in 1:N,b in 1:B,l in 1:L], y[i] + g[i] * ei[i] + (1 - ei[i]) * k[i] <= HB + A * (1 - cibl[i, b, l]))     # 工件高度不能超过模台高度
@constraint(model,[i in 1:N,j in 1:N,i!=j], x[i] + k[i] * ei[i] + (1 - ei[i]) * g[i] <= x[j] + WB * (1 - plij[i, j]))     # 工件横坐标不能重叠
@constraint(model,[i in 1:N,j in 1:N,i!=j], y[i] + g[i] * ei[i] + (1 - ei[i]) * k[i] <= y[j] + HB * (1 - puij[i, j]))     # 工件纵坐标不能重叠       
@constraint(model,[i in 1:N,j in i+1:N,b in 1:B,l in 1:L], plij[i, j] + puij[i, j] + plij[j, i] + puij[j, i] >= cibl[i, b, l] + cibl[j, b, l] - 1)     # 工件不重叠
@constraint(model,[i in 1:N,b in 1:B,w in 1:W,l in 1:L], pbwl[b, w, l] >= piwl[i, w, l] * cibl[i, b, l] )   #模台加工时间不能小于模台内工件的加工时间
@constraint(model,[l in 1:L],cbwl[1, 1, l] >= pbwl[1, 1, l] )    #第一个工作站完工时间不能小于加工时间
@constraint(model,[b in 1:B,l in 1:L,w in 2:W], cbwl[b, w, l] >= cbwl[b, w-1, l] + pbwl[b, w, l])     #当前工作站完工时间不能少于上个工作站完工时间加上当前工作站加工时间
@constraint(model,[b in 2:B,l in 1:L,w in 1:W], cbwl[b, w, l] >= cbwl[b-1, w, l] + pbwl[b, w, l])     #当前批次的完工时间不少于上个批次的完工时间加上本批次的加工时间
@constraint(model,[b in 1:B,w in 1:W,l in 1:L], Cmax >= cbwl[b, w, l])     #最大完工时间不少于每个批次的完工时间

# 求解优化问题
JuMP.set_time_limit_sec(model, 7200)  # 设置时间限制
JuMP.optimize!(model)    #求解模型

# 输出结果
#println("目标加权值: ", value( alpha * sum(gbl[b, l] for l in 1:L for b in 1:B) + (1-alpha) * Cmax ))
println("最大完工时间: ", value( Cmax ))
println("启用模台数量: ", value(sum(gbl[b, l] for l in 1:L for b in 1:B)))

for l in 1:L
    for b in 1:B
        if value(gbl[b, l]) == 1
           println(" 生产线 $l 上的模台 $b 被启用 ")
           for w in 1:W
           println("工作站 $w 开始时间",value(cbwl[b, w, l] - pbwl[b, w, l]),   "加工时间" ,value(pbwl[b, w, l]) ,  "完工时间 " ,value(cbwl[b, w, l]))
           end
        end
    end
end

for i in 1:N
    for l in 1:L
        for b in 1:B
            if value(cibl[i, b, l]) == 1  # 如果工件被分配到该锚台
               println("  工件 $i 放入生产线 $l 的模台 $b 中加工   ")
               if value(ei[i]) == 0
                println("工件 $i (宽度: $(k[i]), 高度: $(g[i])), 旋转放置，左下角坐标: (", value(x[i]), ", ", value(y[i]), "),右上角坐标: (", value(x[i] + g[i]), ", ", value(y[i] + k[i]), ")")
               else
                println("工件 $i (宽度: $(k[i]), 高度: $(g[i])), 平行放置，左下角坐标: (", value(x[i]), ", ", value(y[i]), "),右上角坐标: (", value(x[i] + k[i]), ", ", value(y[i] + g[i]), ")")
               end
            end
        end
    end
end


for i in 1:N
    for w in 1:W
        for l in 1:L
            println("工件 $i 在生产线 $l 的工作站 $w 加工时间" ,value(piwl[i, w, l]))
        end
    end
end